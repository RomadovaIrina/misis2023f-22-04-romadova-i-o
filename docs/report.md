<div style="text-align: right">Выполнила:</div>
<div style="text-align: right">студентка 2 курса,</div>
<div style="text-align: right">гр. БПМ-22-4 Ромадова Ирина Олеговна</div>

# Паттерн Singleton 

## __Определение__


*Паттерн* – шаблон, принятое решение для реализации определенного спектра задач. Является «Хорошим тоном» в разработке.
*Паттерн Синглтон* - Одиночка, относят к порождающим, так как он предназначен для создания некоторого объекта. Синглтон, в частности, нужен для создания заданного числа экземпляров, чаще всего- одного (поэтому и одиночка)

### Что нужно уметь делать:
-	Создавать экземпляр определенного типа
-	Предоставлять доступ извне. Переменная доступна всегда: от запуска программы до ее завершения. К ней предоставлен глобальный доступ — из любой части программы.
-	•	Гарантировать заданное количество экземпляров (Далее речи идет об одном)
### Особенности использования паттерна:
1.	Создание единственного экземпляра: У класса есть один экземпляр и далее он просто ссылается на себя
2.	Предоставляет доступ из любой точки программы- глобальность
3.	Возможны проблемы с многопоточностью.
4.	В отличие от глобальной переменной, состояние синглтона легче отследить
5.	Используется отложенная инициализация (создание происходит по необходимости)
6.	Усложняет тестирование и отслеживание зависимостей:
  - Поскольку синглтон привносит глобальный статус, то нельзя изолировать другие классы, которые используют синглтон
  - Невозможно запустить несколько тестов параллельно
  -	Не всегда один и тот же тест вернет один и тот же результат
  -	Состояние синглтона может меняться по мере выполнения программы

## Вариант реализации LeakySingleton:

Здесь может возникнуть утечка памяти. Но в данном случае удобнее контролировать время жизни объекта
```C++

class LeakySingleton {
private:
    // Приватный конструктор, чтобы предотвратить создание экземпляров извне.
    LeakySingleton() {}
    // Указатель на единственный экземпляр класса.
    inline static LeakySingleton* instance = nullptr;

public:
    // Метод для получения единственного экземпляра класса.
    static LeakySingleton* getInstance() {
        if (!instance) {
            instance = new LeakySingleton();
        }
        return instance;
    }

    static void deleteInstance() {
        delete instance;
    }
};
```

 
Доступ к объекту через статическую функцию-член класса, которая возвращает ссылку или указатель на него. Этот объект создается только в первый раз, а все последующие вызовы возвращают адрес.

## Синглтон Майерса 

Использование синглтона Майерса упрощает процесс очистки памяти, то есть сложнее очистить что-то другое. 

```C++
class MeyersSingleton {
private:
    MeyersSingleton() = default;
    MeyersSingleton(const MeyersSingleton&) = delete;
    MeyersSingleton(MeyersSingleton&& other) = delete;

    ~MeyersSingleton() {};
    int example_value_ = 100;
public:


    MeyersSingleton& operator =(const MeyersSingleton& other) = delete;
    MeyersSingleton& operator=(MeyersSingleton&& other) = delete;
    
    int answer_to_all = 42;
    int GetExapleValue() const {
        return example_value_;
    }
    void SetExampleValue(const int& other) {
        example_value_ = other;
    }
    static MeyersSingleton& getInstance() {
        static MeyersSingleton instance;
        return instance;
    }
};
```
## Заключение:

Существуют и другие паттерны программирования и значит стоит внимательно выбирать какой паттерн следует использовать, потому что синглтон не универсален и при недостаточно хорошей реализации может создать проблемы (утечки памяти, проблемы с многопоточностью)

##### Источники 
1. [Взято за основу как пример LeakySingleton] https://gist.github.com/pazdera/1098119
2. https://laristra.github.io/flecsi/src/developer-guide/patterns/meyers_singleton.html
3. https://refactoring.guru/design-patterns/singleton
4. https://www.modernescpp.com/index.php/thread-safe-initialization-of-a-singleton/
